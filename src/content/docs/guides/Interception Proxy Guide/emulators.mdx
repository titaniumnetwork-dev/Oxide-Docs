---
title: Emulation
description: In this part of the guide, we explain how to implement emulation features into your interception proxy.
sidebar:
  order: 5
---

# Glossary

- **Captured Headers** - Headers that are captured in the Header rewriter, before they are rewritten. These headers are then sent to the client, so that they can be used for emulation, since you can't rewrite the origin to a proxified origin. Not all forms of emulation require this, sometimes you need to emulate in the SW as is the case with policies, such as cache and referrer. In rare cases, you can use client APIs in the sandboxer to emulate this behavior without needing knowledge of the existing policies set by the headers.

# Types of Emulation

Everything, which needs to be emulated includes: errors for all major browsers, Nested SWs, caching, and every security policy.

## Referrer Policy Chain Tracking

:::note
This part is unfinished.
:::

## History State Emulation

:::note
This part is unfinished.
:::

{/* TODO: ... */}

## Error Emulation

The proxy can be revealed

### Proxy Tags (Scramtags)

:::note
This part is unfinished.
:::

{/* TODO: ... */}

## Sub-resource Integrity Emulation

This requires cooperation with the HTML rewriter or interceptor and the service worker.

:::note
This part is unfinished.
:::

{/* TODO: ... */}

## Security Policy Emulation

Many security policy emulation types depend on each other

Nested SW -> CSP emulation
:::note
This part is unfinished.
:::

{/* TODO: ... */}

> -> - meaning depends on here

### CORS Emulation

## Cache Emulation

## Nested SWs

This refers to an interception-focused method of emulation, where you:

1. Create a fake API for the Navigator SW API
2. Communicate with message listeners on the SW, which will bundle. By bundle I mean resolving the `importScripts` in classic scripts and ESM in module scripts.
   :::caution
   This part is unfinished.
   :::
   {/* TODO: ... */}
